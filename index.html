<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lumina - Optimized Crystal Scene</title>

  <!-- Minimal UI styling -->
  <style>
    :root {
      --accent: #6366f1;
      --bg: #0a0a0a;
      --muted: #a0a0a0;
      --glass: rgba(255,255,255,0.04);
    }
    * { box-sizing: border-box; margin:0; padding:0; }
    html,body { height:100%; background:var(--bg); color:#e6e6e6; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    header { position:fixed; top:0; left:0; right:0; height:72px; display:flex; align-items:center; padding:0 5%; background: rgba(10,10,10,0.85); border-bottom:1px solid rgba(99,102,241,0.06); z-index:50; }
    .logo { color:var(--accent); font-weight:800; letter-spacing:2px; font-size:1.2rem; }
    .hero { height:100vh; position:relative; display:flex; align-items:center; justify-content:center; padding-top:72px; overflow:hidden; }
    canvas { position:absolute; inset:0; width:100%; height:100%; display:block; z-index:1; }
    .hero-content { position:relative; z-index: 5; text-align:center; max-width:900px; padding: 2rem; }
    h1 { font-size:2.6rem; background: linear-gradient(135deg,var(--accent), #a855f7); -webkit-background-clip:text; color:transparent; }
    p.lead { color:var(--muted); font-size:1.05rem; margin-top:0.6rem; }

    /* Controls */
    .controls {
      position: fixed;
      right: 20px;
      top: 92px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.04);
      backdrop-filter: blur(6px);
      z-index: 60;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:170px;
    }
    .controls label { font-size:0.78rem; color:var(--muted); display:block; margin-bottom:6px; }
    .controls select, .controls button {
      width:100%;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:var(--glass);
      color:#fff;
      cursor:pointer;
      font-size:0.95rem;
    }
    .controls .row { display:flex; gap:8px; }
    .controls .row button { flex:1; }
    .small-note { font-size:0.72rem; color:var(--muted); margin-top:6px; text-align:center; }

    /* Section styles (kept minimal) */
    section { padding:6rem 5%; max-width:1200px; margin:0 auto; }
    @media (max-width:768px) {
      header { padding:0 4%; }
      h1 { font-size:2rem; }
      .controls { right: 12px; top:86px; min-width:150px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">LUMINA</div>
  </header>

  <main>
    <section class="hero" aria-label="Hero">
      <canvas id="prism-canvas"></canvas>
      <div class="hero-content">
        <h1>Custom Software Solutions for NGOs</h1>
        <p class="lead">Building tools that help organizations evolve their services and reach more people</p>
      </div>
    </section>
  </main>

  <!-- Controls: Performance, Animation toggle, Bloom toggle -->
  <div class="controls" role="region" aria-label="Performance controls">
    <label for="perf-select">Performance Mode</label>
    <select id="perf-select" title="Performance mode">
      <option value="auto">Auto (recommended)</option>
      <option value="high">High Quality</option>
      <option value="low">Low Power</option>
    </select>

    <div class="row" style="margin-top:6px;">
      <button id="toggle-anim">Pause Animation</button>
      <button id="toggle-bloom">Bloom: On</button>
    </div>
    <div class="small-note">Auto mode reduces detail on mobile to save battery.</div>
  </div>

  <!-- Three.js (module imports) -->
  <script type="module">
    // Use r128 modules from jsdelivr
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
    import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

    const canvas = document.getElementById('prism-canvas');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 6;

    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setClearColor(0x0a0a0a, 0); // keep background transparent-ish
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));

    // Controls (helpful for dev; disabled by default)
    // const controls = new OrbitControls(camera, renderer.domElement);
    // controls.enabled = false;

    // Performance settings (defaults; adapted on 'auto')
    let settings = {
      particleCount: 100,
      smallCrystalDetail: 0, // 0 = low, 1 = medium
      useBloom: true,
      animationEnabled: true
    };

    // Auto-detect mobile-ish devices
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth <= 768;

    // Adjust for auto mode
    function applyPerfMode(mode) {
      if (mode === 'auto') {
        if (isMobile) {
          settings.particleCount = 40;
          settings.smallCrystalDetail = 0;
        } else {
          settings.particleCount = 120;
          settings.smallCrystalDetail = 1;
        }
      } else if (mode === 'high') {
        settings.particleCount = 220;
        settings.smallCrystalDetail = 1;
      } else if (mode === 'low') {
        settings.particleCount = 30;
        settings.smallCrystalDetail = 0;
      }
      rebuildParticles();
      rebuildSmallCrystals();
      // Update renderer pixel ratio per mode
      renderer.setPixelRatio(mode === 'high' ? Math.min(window.devicePixelRatio || 1, 2) : 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      // Also adjust composer renderTarget resolution if composer exists
      if (composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
      }
    }

    // Scene objects
    const crystalGroup = new THREE.Group();
    scene.add(crystalGroup);

    // Main crystal
    const mainGeometry = new THREE.OctahedronGeometry(1.8, 0);
    const mainMaterial = new THREE.MeshPhongMaterial({
      color: 0x6366f1,
      emissive: 0x6366f1,
      emissiveIntensity: 0.8,
      transparent: true,
      opacity: 0.78,
      shininess: 80,
      specular: 0xffffff
    });
    const mainCrystal = new THREE.Mesh(mainGeometry, mainMaterial);
    crystalGroup.add(mainCrystal);

    // Core
    const coreGeometry = new THREE.SphereGeometry(0.5, 24, 24);
    const coreMaterial = new THREE.MeshBasicMaterial({ color: 0xa855f7, transparent: true, opacity: 0.95 });
    const core = new THREE.Mesh(coreGeometry, coreMaterial);
    crystalGroup.add(core);

    // Rays
    const rayGroup = new THREE.Group();
    for (let i = 0; i < 6; i++) {
      const g = new THREE.CylinderGeometry(0.02, 0.001, 8, 6);
      const m = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
      const mesh = new THREE.Mesh(g, m);
      const angle = (i * Math.PI * 2) / 6;
      mesh.rotation.z = angle;
      mesh.position.x = Math.cos(angle) * 0.5;
      mesh.position.y = Math.sin(angle) * 0.5;
      rayGroup.add(mesh);
    }
    crystalGroup.add(rayGroup);

    // Wireframe
    const edges = new THREE.EdgesGeometry(mainGeometry);
    const wireframe = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }));
    crystalGroup.add(wireframe);

    // Orbiting small crystals (rebuildable)
    let smallCrystals = [];
    function rebuildSmallCrystals() {
      // remove existing
      smallCrystals.forEach(s => crystalGroup.remove(s));
      smallCrystals = [];
      const detail = settings.smallCrystalDetail; // not used for tetra but placeholder
      const count = 3;
      for (let i=0;i<count;i++) {
        const geo = new THREE.TetrahedronGeometry(0.32, detail);
        const mat = new THREE.MeshPhongMaterial({ color: 0xa855f7, emissive: 0xa855f7, emissiveIntensity: 0.45, transparent: true, opacity: 0.55 });
        const m = new THREE.Mesh(geo, mat);
        smallCrystals.push(m);
        crystalGroup.add(m);
      }
    }
    // initial build
    rebuildSmallCrystals();

    // Particles (rebuildable)
    let particles, particlesGeometry, particlePositions, particleVelocities;
    function rebuildParticles() {
      if (particles) {
        scene.remove(particles);
        particles.geometry.dispose();
        particles.material.dispose();
        particles = null;
      }
      const particleCount = Math.max(1, Math.floor(settings.particleCount));
      particlesGeometry = new THREE.BufferGeometry();
      particlePositions = new Float32Array(particleCount * 3);
      particleVelocities = [];
      for (let i=0;i<particleCount;i++){
        particlePositions[i*3+0] = (Math.random()-0.5)*10;
        particlePositions[i*3+1] = (Math.random()-0.5)*10;
        particlePositions[i*3+2] = (Math.random()-0.5)*10;
        particleVelocities.push({
          x: (Math.random()-0.5)*0.02,
          y: (Math.random()-0.5)*0.02,
          z: (Math.random()-0.5)*0.02
        });
      }
      particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
      const particleMaterial = new THREE.PointsMaterial({ size: 0.05, transparent:true, opacity:0.85, blending: THREE.AdditiveBlending });
      particles = new THREE.Points(particlesGeometry, particleMaterial);
      scene.add(particles);
    }
    // initial particles build
    applyPerfMode('auto'); // sets particles and small crystals properly via rebuild calls

    // Lights
    const light1 = new THREE.PointLight(0x6366f1, 2.5, 100);
    light1.position.set(5,5,5);
    scene.add(light1);
    const light2 = new THREE.PointLight(0xa855f7, 2.5, 100);
    light2.position.set(-5,-5,5);
    scene.add(light2);
    const light3 = new THREE.PointLight(0x3b82f6, 1.6, 100);
    light3.position.set(0,5,-5);
    scene.add(light3);
    const ambientLight = new THREE.AmbientLight(0x404040, 0.28);
    scene.add(ambientLight);

    // Post-processing setup
    let composer, bloomPass;
    const renderPass = new RenderPass(scene, camera);
    function setupComposer() {
      // dispose existing
      if (composer) {
        composer.dispose();
        composer = null;
      }
      composer = new EffectComposer(renderer);
      composer.addPass(renderPass);
      bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.4, 0.85);
      bloomPass.threshold = 0.2;
      bloomPass.strength = 0.9; // bloom intensity
      bloomPass.radius = 0.45;
      composer.addPass(bloomPass);
    }
    setupComposer();

    // Mouse
    let mouseX = 0, mouseY = 0, targetX = 0, targetY = 0;
    document.addEventListener('mousemove', (e) => {
      mouseX = (e.clientX / window.innerWidth) * 2 - 1;
      mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
    });

    // Animation control state
    let time = 0;
    let rafId = null;

    function animateLoop() {
      rafId = requestAnimationFrame(animateLoop);
      if (!settings.animationEnabled) return; // skip updates, but still leave frame active to allow resume without re-binding

      time += 0.01;

      // smooth mouse
      targetX += (mouseX - targetX) * 0.05;
      targetY += (mouseY - targetY) * 0.05;

      crystalGroup.rotation.x = time * 0.2 + targetY * 0.3;
      crystalGroup.rotation.y = time * 0.3 + targetX * 0.3;

      // hue cycle
      const hue = (time * 0.08) % 1;
      const rainbow = new THREE.Color();
      rainbow.setHSL(hue, 1.0, 0.5);

      mainMaterial.color.copy(rainbow);
      mainMaterial.emissive.copy(rainbow);
      mainMaterial.emissiveIntensity = 0.9 + Math.sin(time * 2) * 0.4;

      coreMaterial.color.copy(rainbow);

      // small crystals orbit
      smallCrystals.forEach((crystal, i) => {
        const angle = time + (i * Math.PI * 2 / smallCrystals.length);
        const radius = 3;
        crystal.position.x = Math.cos(angle) * radius;
        crystal.position.y = Math.sin(angle * 1.5) * radius * 0.45;
        crystal.position.z = Math.sin(angle) * radius;
        crystal.rotation.x = time * 2;
        crystal.rotation.y = time * 3;
        const smallColor = new THREE.Color();
        smallColor.setHSL((hue + i * 0.33) % 1, 1.0, 0.5);
        crystal.material.color.copy(smallColor);
        crystal.material.emissive.copy(smallColor);
      });

      // particles
      if (particles) {
        const positions = particles.geometry.attributes.position.array;
        const pc = positions.length / 3;
        for (let i = 0; i < pc; i++) {
          const i3 = i * 3;
          positions[i3] += particleVelocities[i].x;
          positions[i3 + 1] += particleVelocities[i].y;
          positions[i3 + 2] += particleVelocities[i].z;
          if (Math.abs(positions[i3]) > 5) particleVelocities[i].x *= -1;
          if (Math.abs(positions[i3 + 1]) > 5) particleVelocities[i].y *= -1;
          if (Math.abs(positions[i3 + 2]) > 5) particleVelocities[i].z *= -1;
        }
        particles.geometry.attributes.position.needsUpdate = true;
        particles.rotation.y = time * 0.06;
      }

      // lights
      light1.intensity = 2.5 + Math.sin(time * 2) * 0.9;
      light2.intensity = 2.5 + Math.sin(time * 2 + Math.PI) * 0.9;
      light3.intensity = 1.6 + Math.sin(time * 3) * 0.4;

      // render via composer for bloom when enabled
      if (settings.useBloom && composer) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }

    // Start the loop (but actual step updates only occur when animationEnabled is true)
    animateLoop();

    // UI wiring
    const perfSelect = document.getElementById('perf-select');
    const toggleAnimBtn = document.getElementById('toggle-anim');
    const toggleBloomBtn = document.getElementById('toggle-bloom');

    // initialize UI state
    perfSelect.value = 'auto';
    toggleAnimBtn.textContent = settings.animationEnabled ? 'Pause Animation' : 'Resume Animation';
    toggleBloomBtn.textContent = settings.useBloom ? 'Bloom: On' : 'Bloom: Off';

    perfSelect.addEventListener('change', (e) => {
      const mode = e.target.value;
      applyPerfMode(mode);
    });

    toggleAnimBtn.addEventListener('click', () => {
      settings.animationEnabled = !settings.animationEnabled;
      toggleAnimBtn.textContent = settings.animationEnabled ? 'Pause Animation' : 'Resume Animation';
      // If animation was re-enabled and rafId is null (shouldn't happen), ensure loop runs
      if (settings.animationEnabled && rafId === null) {
        animateLoop();
      }
    });

    toggleBloomBtn.addEventListener('click', () => {
      settings.useBloom = !settings.useBloom;
      toggleBloomBtn.textContent = settings.useBloom ? 'Bloom: On' : 'Bloom: Off';
    });

    // Resize handling
    function onResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      if (composer) composer.setSize(w, h);
    }
    window.addEventListener('resize', onResize, { passive:true });

    // clean disposal on page unload (nice to have)
    window.addEventListener('beforeunload', () => {
      if (rafId) cancelAnimationFrame(rafId);
      renderer.dispose();
      if (composer) composer.dispose();
    });

    // ensure initial canvas size
    onResize();
  </script>
</body>
</html>

